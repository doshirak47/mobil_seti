clear all;
close all;
m = 8; %длинна информационной последовательности
crc = [1 0 1 0 0 1 1 0 1 0 1 1 1 1 0 0 1]; %crc16 m=8 x16+x13+x12+x11+x10+x8+x6+x5+x2+1
% crc = [1 0 1 0 1 0 1 1 1]; %crc8 m=4 x8+x7+x6+x4+x2+1
% crc = [1 1 1 0 1]; % x4+x2+x+1 m=3
% crc = [1 1 0 1]; % x3+x+1 m=4 каравай,каравай, кого хочешь, выбирай
r = length(crc)-1 ;%длина КС
index = 1;%индекс, как он есть по словарю
n = 250000;%тесты, 250к секунд 15 считаются, не заставляйте делать больше, молю
snr_arr = -30:5:10;%отношение сигнал шум практическое, сейчас норм масштаб
snr_theor_arr = -30:10;%%отношение сигнал шум теоретическое, сейчас норм масштаб

Pe_decode_Theor = ones(1,length(snr_theor_arr)).*(1/2^r);%верхняя оценка вер. ош. декод.
Pb_theor = qfunc(sqrt(2*(10.^(snr_theor_arr./10))));%теоретическая вероятность ошибки на бит для BPSK

codewords = zeros(2^m, m+r);%массив кодовых слов
modulate_codewords = zeros(2^m, m+r);%массив уже модулированных кодовых слов
W = zeros((2^m), 1);%массив весов всех кодовых слов
for word = 0:2^m-1%цикл по всем возможным сообщениям
    [~, c] = gfdeconv(de2bi(bitshift(word, r)), crc);%вычисляется КС по формуле
    codewords(word+1, :) = de2bi(bitxor((bitshift(word, r)), bi2de(c)), m+r);%прибавляем к сообщ. КС, те получаем кодовое слово
    W(word+1) = nnz(codewords(word+1, :));%считаем вес слова и добавляем его в массив
    modulate_codewords(word+1, :) = codewords(word+1, :).*(2)-1;%модуляция кодового слова, те берем кодовые слова и их модулируем
end
d_min = min(W(2:end));%мин расстояние кода вычисляется
P_ed = zeros(1, length(Pb_theor));%точная вероятность ошибки декодирования
for p = Pb_theor%идем по ошибке на бит
    tmp = 0;
    for i = d_min:(m+r)%теперь идем от мин расстояния кода до длинны кодового слова
        Ai = sum(W == i);%считаем кол-во кодовых слов веса i
        tmp = tmp + (Ai * p^i * (1-p)^((m+r)- i));%формула номер 3 Точная вероятность ошибки декодирования CRC [2]
    end
    P_ed(index) = tmp;%запоминаем значение формулы(суммы)
    index = index + 1;%увеличиваем индекс по словарю
end
index = 1;%обнуляем, дальше юзанем этого универсального солдата со значением по словарю

Pb = zeros(1, length(snr_arr));%массив для практической ошибки на бит
Pe_decode = zeros(1, length(snr_arr));% массив для практической ошибки декодирования
for SNR = snr_arr%идем по SNRу
    N_b = 0;%счетчик ошибок на бит
    Ne_decode = 0;%счетчик ошибок декодирования
    SNRi = 10^(SNR/10);%перевод из дб в разы
    sigma = sqrt(1/(2*SNRi));%
    for i = 1:n
        %создание сообщения
        rnd_ind = randi(2^m,1);%рандомный индекс выбирается по которому вытащим модулированное кодовое слово
        massage = modulate_codewords(rnd_ind, :);%вытаскиваем модулированное кодовое слово
        %канал
        b_m = massage +sigma*randn(1, length(massage));%добавляется шум к сообщению в канале (АБГШ)
        %демодулятор
        b = b_m > 0;%демодулируем согласно схеме(если больше 0, то 1, иначе 0), те получаем демодулированное кодовое слово
        %декодер
        a = codewords(rnd_ind, :);%вытаскиваем кодовое слово
        e = xor(a,b);%считаем вектор ошибок 
        N_b = N_b + nnz(e);%считаем сколько 1 в векторе ошибок и прибавляем к этому счетчику, те колво ошибочных бит
        [~, s] = gfdeconv(double(b), crc);%вычисляем синдром, те приводим по модулю g(x)(crc вообщем)
        if (bi2de(s) == 0) & (nnz(e) ~= 0)%если синдром равен 0, но вектор ошибок не равен нулю, то была ошибка декодирования и счетчик увеличиваем
            Ne_decode = Ne_decode + 1;% увеличиваем счетчик ошибок декодирования
        end
    end
    
    Pb(index) = N_b/(n*(m+r));%практическая ошибка на бит
    Pe_decode(index) = Ne_decode/n;%вероятность ошибки декодирования 
    index = index + 1;%родной универсальный солдат
end

figure(1);%график ошибки на бит теор и практ
semilogy(snr_theor_arr, Pb_theor, 'r', snr_arr, Pb, 'bo');
legend('Pb theor', 'Pb pract');
figure(2);%график вероятности ошибки декодирования
semilogy(snr_theor_arr, Pe_decode_Theor, 'g', snr_arr, Pe_decode, 'bo', snr_theor_arr, P_ed, 'r');
legend('Ped upper boound', 'Ped pract', 'Ped theor');
